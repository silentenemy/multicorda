\chapter{Интересные моменты}

В процессе разработки я столкнулся с некоторыми неочевидными багами.

\section{Переход в защищённый режим}

Во время отладки перехода в защищённый режим возникла проблема, приводившая к исключению Double Fault (8h) \cite{exceptions}. Это исключение возникает в том случае, если происходит процессорное исключение во время обработки другого исключения. Double Fault является прерыванием типа Abort, после которого стабильное продолжение работы программы крайне затруднительно, а сама причина возникновения исключения обычно связана с неудачной реализацией сегментации, обработки прерываний или всего вместе. 

Я убедился в том, что GDT была написана верно, и стал отлаживать код перехода. Нюанс заключался в том, что нельзя загружать в сегментные регистры селекторы сегментов GDT до тех пор, пока не будет выставлен младший бит cr0 (бит защищённого режима) и пока не будет произведён far jump в область кода с селектором сегмента кода, например: \verb|jmp 08h:.fix_segment_registers|. Только после выполнения этих двух условий можно загружать селекторы сегментов в сегментные регистры.

\section{Ремаппинг PIC-контроллеров}

После написания обработчика прерываний клавиатуры (21h) я демаскировал прерывания PIC-контроллера и столкнулся с исключением процессора Double Fault.

Неочевидность ситуации была в том, что сообщений о первом прерывании не было. Это навело на мысль о том, что прерывание может быть не связано с реальным исключением процессора. После подробного изучения ситуации в Bochs я обнаружил, что PIT (программируемый таймер прерываний) срабатывал как раз в момент Double Fault.

Баг заключался в том, что векторы прерываний PIC-контроллеров не были перенесены на 20h-2Fh, а остались в области 8h-17h. Это было связано с тем, что процедура ремаппинга PIC-контроллеров неправильно составляла запрос, используя and вместо or для вычисления значения, передаваемого PIC-контроллеру.

\section{Настройка IDT}

Когда я реализовывал обработчики прерываний, мной был найден баг, из-за которого срабатывал только обработчики 0h и 8h (Double Fault). Ошибка заключалась в неправильном составлении IDT, а именно указатель на записи в IDT сдвигался на 64 байта, а не на 8 (длину записи).